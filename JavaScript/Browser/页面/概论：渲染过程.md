浏览器主进程、网络进程、渲染进程

1. 浏览器主进程把url发给网络进程。

2. 网络进程收到url后，从本地缓存中找是否有对应的资源，如果有，则把资源直接返回给浏览器进程。如果没有，则进入真正的请求流程。

3. 具体的请求流程：
（1）DNS解析，得到服务器的ip地址
（2）根据ip地址与服务器建立TCP连接
（3）构建请求信息，包括请求头、请求行等，并发送请求。

4. 网络进程拿到响应数据后，包括响应头、响应体等。进行如下操作（解析响应头）
（1）判断响应头的状态是否是301、302，如果是，就重新走流程，把刚才的过程重新来一遍。如果不是，解析响应头。
 小提示： 可以通过 `curl -I www.baidu.com` 查看服务器返回的响应头信息。
（2）根据响应头的Content-Type判断响应数据的类型，如果判断为下载类型，就把该请求发给下载管理器。如果不是，就开始准备渲染。

5. 准备渲染阶段，如果从A页面打开B页面，A和B是同一站点（协议+根域名），那么B页面复用A页面的渲染进程，如果是其他情况，那么会为B页面新开一个渲染进程。

6. 浏览器进程将网络进程的收到的数据给渲染进程，具体如下:
（1）浏览器进程收到网络进程发来的响应头数据，会像渲染进程发起 ”提交文档“的请求
（2）渲染进程收到之后，会和网络进程建立一个数据管道进行传输
（3）传输完毕后， 渲染进程会告诉浏览器主进程，及返回给主进程”确认提交“的消息。
（4）浏览器主进程收到确认提交的消息后，去更新浏览器页面，有安全状态、地址栏、前进后退，更新web页面等。

7. 开始传输时，就开始页面解析、资源加载。渲染过程如下
（1） 构建DOM树： 把接受到的html编程浏览器能认识的结构-DOM树
输入HTML => HTML解析 => 输出DOM树

（2）样式计算：计算出每个dom节点的样式
第一步：把css转换为浏览器能理解的结构
通过link标签获取的外部css文件、style 标记的css、元素内嵌的css => css解析 => styleSheets

第二歩：转换样式表的属性值，进行标准化处理
例如2em被解析换成32px; red解析成 rgb(255, 0, 0)

第三步：计算dom树中每个节点具体样式
根据css的继承、层叠这两个规则，计算得出。

（3）布局：计算dom树中可见元素的几何位置
创建布局树和布局计算。


渲染过程：
（一）构建DOM树
1. 目的： 把html转换成浏览器认识的结构（dom树）
2. 过程： 输入Html，解析html，得到Dom树

（二）样式计算
1. 目的：计算出每个dom节点的样式
2. 过程：
（1）解析css，将css变成浏览器认识的结构--styleSheets。可通过document.styleSheets查看
（2）属性值标准化。比如会把#fff变成rgb(255,255,255), bold变成700。
（3）计算每个节点的样式（需学习层叠样式规则），最终的样式保存在computedStyle中。
  根据dom节点的继承关系和css层叠关系计算样式

（三）布局
1. 目的：计算出DOM树中可见元素的几何位置。
2. 过程：
（1）创建布局树：dom树上有些元素是不可见的，比如head和display：none的元素。因此创建一个只包含可见元素的布局树。
（2）计算布局树节点的坐标计算。


（四）分层
1. 目的： 为特定节点生成专门的图层，并生成图层树
2. 过程：
  特定节点要求（满足其中一个）：
  （1）拥有层叠上下文属性的元素会提升为单独一层。层叠上下文属性：明确定位属性、透明属性、css滤镜、z-index等
  （2）发生裁剪的元素会被提升为单独一层。

（五）绘制
 根据图层树，为每个图层生成绘制列表。

（六）栅格化
目的：将图块变成位图。
（七）合成







习题：
1. css 是否会阻塞dom解析？
当从服务器接收HTML页面的第一批数据时，DOM解析器就开始工作了，在解析过程中，如果遇到了JS脚本，如下所示：
<html>
    <body>
        极客时间
        <script>
        document.write("--foo")
        </script>
    </body>
</html>
那么DOM解析器会先执行JavaScript脚本，执行完成之后，再继续往下解析。

那么第二种情况复杂点了，我们内联的脚本替换成js外部文件，如下所示：
<html>
    <body>
        极客时间
        <script type="text/javascript" src="foo.js"></script>
    </body>
</html>
这种情况下，当解析到JavaScript的时候，会先暂停DOM解析，并下载foo.js文件，下载完成之后执行该段JS文件，然后再继续往下解析DOM。这就是JavaScript文件为什么会阻塞DOM渲染。

我们再看第三种情况，还是看下面代码：
<html>
    <head>
        <style type="text/css" src = "theme.css" >
    </head>
    <body>
        <p>极客时间</p>
        <script>
            let e = document.getElementsByTagName('p')[0]
            e.style.color = 'blue'
        </script>
    </body>
</html>
当我在JavaScript中访问了某个元素的样式，那么这时候就需要等待这个样式被下载完成才能继续往下执行，所以在这种情况下，CSS也会阻塞DOM的解析。